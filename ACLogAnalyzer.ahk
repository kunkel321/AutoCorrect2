; ==============================================================================
;             AUTO CORRECTION LOG ANALYZER
; Updated:  10-30-2024
; Determines frequency of items in AutoCorrects Log file, then sorts by freq.  
; Date not factored in sort. There's no hotkey, just run the script.  
; It reports the top X hotstrings that were immediately followed by 
; 'Backspace' (<<), and how many times they were used without backspacing (--)).
; Sort one or the other. Intended for use with kunkel321's 'AutoCorrect for v2.'
; Items are reported in Gui, as radio buttons.  User is given option to 'Go to' 
; item in HotStringLibrary, open it in HotStringHelper2, and/or Cull from embedded
; log at the bottom.  Items culled from ACLog file will get added to the 
; RemovedHotStrings file.  This helps us avoid inadvertently "re-adding" them later.
; Fully functional script was written by current human (kunkel321), then totally 
; refactored (with lots of debugging) using ClaudeAI. 
;===============================================================================
#SingleInstance Force
#Requires AutoHotkey v2+
^Esc::ExitApp ; Emergency kill switch: Ctrl+Esc

; ======= Settings =======================
SortByBS := 1       ; Sort by "Backspaced" items or "Kept" items?
ShowX := 25         ; Show this many top results in report.
myAutoCorrectScript := "AutoCorrect2.ahk"
HotstringLibrary := "HotstringLib.ahk"
ACLog := "AutoCorrectsLog.txt"
startLine := 7      ; Don't scan log until getting the this linemumber.
RemovedHsFile := "RemovedHotstrings.txt" ; File containing hotstrings removed (culled) from log. 
CullDateFormat := "MM-dd-yyyy"
MyAhkEditorPath := "C:\Users\" A_UserName "\AppData\Local\Programs\Microsoft VS Code\Code.exe"
TraySetIcon(A_ScriptDir "\icons\AcAnalysis.ico")
;========================================

; other global variables
ReportArray := []
workingItem := " (No lookup history)"

InitializeSettings()
Main()

InitializeSettings() {
    ; colorThemeSettings.ini is a component of the ColorThemeIntegrator Tool.
    ; https://github.com/kunkel321/ColorThemeIntegrator
    if FileExist("colorThemeSettings.ini") {
        settingsFile := "colorThemeSettings.ini"
        global fontColor := IniRead(settingsFile, "ColorSettings", "fontColor")
        global listColor := IniRead(settingsFile, "ColorSettings", "listColor")
        global formColor := IniRead(settingsFile, "ColorSettings", "formColor")

        radioColorLight := "0x00FFFF"  ; The color of the radio buttons in the gui form.
        radioColorDark := "Blue"       ; The color of the radio buttons in the gui form.
        ; Determine general "darness" of formColor, and chose contrasting radio color. 
        global radioColor := (GetColorDarkness(formColor) < 50)? radioColorDark : radioColorLight
        GetColorDarkness(hexColor) { ; This function mostly generated by Claude.ai
            hexColor := StrReplace(hexColor, "#", "")  ; Remove the '#' if present
            hexColor := StrReplace(hexColor, "0x", "")  ; Remove the '0x' if present
            r := Integer("0x" . SubStr(hexColor, 1, 2))   ; Extract R, G, B values
            g := Integer("0x" . SubStr(hexColor, 3, 2))
            b := Integer("0x" . SubStr(hexColor, 5, 2))
            brightness := (r * 0.299 + g * 0.587 + b * 0.114) / 255   ; Calculate perceived brightness
            darkness := 101 - Round(brightness * 100)   ; Map brightness to a scale of 1-10
            return Max(1, Min(100, darkness))   ; Ensure the result is within 1-10 range
        }
    }
    Else { ; If user doesn't have ColorThemeIntegrator, just use these.
        global fontColor := "Default" ; <--- Change as desired. This is the color of the words.
        global listColor := "Default" ; <--- Change as desired. This is the color of the cull notes editbox.
        global formColor := "Default" ; <--- Change as desired. Color or GUI forms.
        global radioColor := "Blue"
    }    
}

Main() {
    AllStrs := FileRead(ACLog)
    TotalLines := StrSplit(AllStrs, "`n").Length
    
    pgObj := CreateProgressGui(TotalLines)
    Report := ProcessLines(AllStrs, TotalLines, pgObj)
    pgObj.gui.Destroy()
    
    global ReportArray := PrepareReport(Report)
    AnalysisResults()
}

CreateProgressGui(TotalLines) {
    pg := Gui()
    pg.Opt("-MinimizeBox +alwaysOnTop +Owner")
    MyProgress := pg.Add("Progress", "w400 h30 cGreen Range0-" . TotalLines, "0")
    reportType := "Top " ShowX (SortByBS? " backspaced autocorrects." : " kept autocorrects.")
    pg.Title := reportType "  Percent complete: 0 %."
    pg.Show()
    return {gui: pg, progress: MyProgress, reportType: reportType}
}

ProcessLines(AllStrs, TotalLines, pgObj) {
    Report := ""
    Loop parse AllStrs, "`n`r" {
        pgObj.progress.Value += 1
        pgObj.gui.Title := pgObj.reportType "  Percent complete: " Round((pgObj.progress.Value/TotalLines)*100) "%."
        
        oStr := SubStr(A_LoopField, 15)
        okTally := 0, bsTally := 0
        
        Loop parse AllStrs, "`n`r" {
            iStr := SubStr(A_LoopField, 15)
            If iStr = oStr {
                If SubStr(A_LoopField, 12, 2) = "--"
                    okTally++
                If SubStr(A_LoopField, 12, 2) = "<<"
                    bsTally++
            }
        }
        
        Report .= FormatReportLine(bsTally, okTally, oStr)
        AllStrs := StrReplace(AllStrs, oStr, "Cap fix")
    }
    return Report
}

FormatReportLine(bsTally, okTally, oStr) {
    spacing := ((bsTally > 9 || okTally > 9) ? "  " : "     ")
    if (SortByBS = 1)
        return Format("{1}<< and {2}-- for{3}{4}`n", bsTally, okTally, spacing, oStr)
    else
        return Format("{1}-- and {2}<< for{3}{4}`n", okTally, bsTally, spacing, oStr)
}

PrepareReport(Report) {
    Report := Sort(Sort(Report, "/U"), "NR")
    trunkReport := ""
    Loop Parse, Report, "`n" {
        if (A_Index <= ShowX && A_LoopField != "")
            trunkReport .= A_LoopField "`n"
        else if (A_Index > ShowX)
            break
    }
    return StrSplit(RTrim(trunkReport, "`n"), "`n")
}

AnalysisResults() {
    global workingItem := " (No lookup history)"
    Global SortByBS
    global aca := Gui(, 'AC Analysis Report')
    aca.SetFont('s12 ' (FontColor ? "c" FontColor : ""))
    aca.BackColor := formColor
    If (SortByBS = 1)
        aca.AddText(,'The ' ShowX ' most frequntly Backspaced items are below.`nAnalyze in HH and Cull separately.  Culling adds`nitem to ' RemovedHsFile ' file.')
    else
        aca.AddText(,"The " ShowX " most frequntly KEPT items are below.`nYOU PROBABLY DON'T WANT TO CHANGE THESE!")
    global radioColor
    aca.SetFont('c' radioColor)
    CreateRadioButtons()
    CreateActionButtons()
    
    aca.Show('yCenter x' (A_ScreenWidth/2) " autosize")
    WinSetAlwaysOnTop(1, "A")
    aca.OnEvent('Escape', (*) => ExitApp())
}

CreateRadioButtons() {
    global radioColor
    if (ReportArray.Length = 0) {
        aca.Add("Text", "w300", "No items to display.")
        return
    }
    For idx, citem in ReportArray {
        options := (idx = 1) ? 'vRadioGrp' : 'xs y+5'
        aca.Add('Radio', options, "Found " citem)
    }
}

CreateActionButtons() {
    buttons := [
        {label: 'Send to HH', callback: SendToHH},
        {label: 'Go To', callback: goToHS},
        {label: 'Cull From Log', callback: cullFromLog},
        {label: 'Close', callback: (*) => ExitApp()}
    ]
    
    For idx, btn in buttons {
        newBtn := aca.Add('Button', (idx > 1 ? 'x+5 ' : '') 'Default', btn.label)
        newBtn.OnEvent('Click', btn.callback)
    }
}

SendToHH(*) {
    result := ProcessSelectedItem()
    if (result) {
        global workingItem := result.workingItem
        myACFileBaseName := StrSplit(myAutoCorrectScript, ".")[1]

        ; Check if the file exists
        if (!FileExist(myACFileBaseName . ".exe")) {
            MsgBox("Error: " myACFileBaseName ".exe not found in the current directory.")
            return
        }
        
        Run myACFileBaseName ".exe /script " myAutoCorrectScript " " workingItem
        aca.Show()
    }
}

goToHS(*) {
    result := ProcessSelectedItem()
    if (result) {
        global workingItem := result.workingItem
        selItemArr := StrSplit(workingItem, ":")
        selItemTrigger := selItemArr[2] ":" selItemArr[3] "::"
        
        if !WinExist(HotstringLibrary)
            Run MyAhkEditorPath " " HotstringLibrary
        WinWait(HotstringLibrary)
        WinActivate
        SendInput "^f"
        Sleep 200
        SendInput selItemTrigger
        aca.Show()
    }
}

cullFromLog(*) {
    result := ProcessSelectedItem()
    if (result) {
        selectedItem := result.workingItem
        fullItemName := result.fullItemName
        
        if (workingItem != selectedItem && workingItem != " (No lookup history)") {
            if (MsgBox("Warning: Different items detected`nYou were working on: " workingItem "`nBut you're culling: " selectedItem "`n`nDo you want to continue?", "Item Mismatch", 4) != "Yes") {
                aca.Show()
                return
            }
        }
        global fontColor, listColor, formColor, SortByBS
        confGUI := Gui()
        confGUI.SetFont('s12 ' (FontColor ? "c" FontColor : ""))
        confGUI.BackColor := formColor
        If (SortByBS = 1) {
            confGUI.AddText(,
                "Confirm culling item...`n" selectedItem "`n"
                "--------------------`n"
                "Add optional notes to culled item."
            )
        }
        Else {
            confGUI.AddText(,"THESE ARE SORTED BY *KEPT*`nSo you probably don't want to`nchange or cull the item.")
        }
        confirmNotes := confGUI.AddEdit("w305 " (listColor ? "Background" listColor : ""), "")
        confGUI.AddButton("w150", "Cull Item").OnEvent("Click", DoCullItem)
        confGUI.AddButton("w150 x+5", "Cancel").OnEvent("Click", cancelCull)
        confGUI.Show()
        cancelCull(*) {
            confGUI.Destroy()
            aca.Show()
            return
        }
        DoCullItem(*) {
            If (confirmNotes.Value != "") 
                selectedItem .= " (" confirmNotes.Value ")"
            confGUI.Destroy()
            CullItemFromLog(selectedItem)
        }
        global workingItem := " (No lookup history)"  ; Reset after culling
    }
}

ProcessSelectedItem() {
    global selectedItem := aca.Submit()
    if (selectedItem.RadioGrp = 0) {
        MsgBox 'Nothing selected.'
        aca.Show()
        return false
    }
    
    fullItemName := ReportArray[selectedItem.RadioGrp]
    workingItem := ExtractItemName(fullItemName)
    return {workingItem: workingItem, fullItemName: fullItemName}
}

ExtractItemName(selItemName) {
    splitStr := SortByBS ? "-- for" : "<< for"
    parts := StrSplit(selItemName, splitStr)
    return Trim(parts[parts.Length], " `n`r")  ; Always take the last part
}

CullItemFromLog(itemToCull) {
    thisFileContents := FileRead(ACLog)
    newFileContents := ""

    CullItemAndDate := "Removed " FormatTime(A_Now, CullDateFormat) " -> " itemToCull "`n"
    FileAppend(CullItemAndDate, RemovedHsFile)

    for scriptLine in StrSplit(thisFileContents, "`n")
        if !InStr(scriptLine, itemToCull)
            newFileContents .= scriptLine "`n"
    
    FileDelete(ACLog)
    FileAppend(newFileContents, ACLog)
    SoundBeep
    ExitApp()
    ;MsgBox("Item culled and added`nto 'Removed' list:`n`n" itemToCull)
}
